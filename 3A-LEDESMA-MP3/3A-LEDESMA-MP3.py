# -*- coding: utf-8 -*-
"""3A-LEDESMA-MP3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXQOUBk7gXPSb7Ip6P0RXB-TBw693Cbv

# **Machine Problem: Interactive Probability and Decision-Making in AI**

---

**Objective**
- In this machine problem, you will apply probability theory, Bayesian inference, and decisionmaking under uncertainty to real-world scenarios using Python. The goal is to create an interactive Python program that allows you to simulate and visualize probabilistic reasoning in various AI contexts.

### Part 1: Implement Basic Probability Calculations

---

1. Task: Write Python functions to calculate the following

- Joint Probability
"""

def joint_probability(p_a, p_b):
    return p_a * p_b

"""- Marginal Probability"""

def marginal_probability(p_a_given_b, p_b):
    return p_a_given_b * p_b

"""- Conditional Probability"""

def conditional_probability(p_a_and_b, p_b):
    return p_a_and_b / p_b

"""2. Interactive Component

"""

def main():
    p_a = float(input("Enter the probability of event A: "))
    p_b = float(input("Enter the probability of event B: "))
    p_b_given_a = float(input("Enter the probability of B given A: "))

    joint_prob = joint_probability(p_a, p_b)
    print(f"\nJoint probability: {joint_prob}")

    marginal_prob = marginal_probability(p_b_given_a, p_a)
    print(f"\nMarginal probability: {marginal_prob}")

    cond_prob = conditional_probability(joint_prob, p_b)
    print(f"\nConditional probability: {cond_prob}")

main()

"""### Part 2: Bayesian Inference for Real-World Scenarios

---

1. Task: Implement a Python function that uses Bayesian inference to update
probabilities based on new evidence.
"""

def bayesian_inference(p_prior, p_pos_given_disease, p_pos):
    return (p_pos_given_disease * p_prior) / p_pos

"""2. Interactive Component:

"""

p_prior = float(input("Enter the prior probability of disease: "))
p_pos_given_disease = float(input("Enter the likelihood of a positive test given disease: "))
p_pos = float(input("Enter the overall probability of a positive test: "))

posterior_prob = bayesian_inference(p_prior, p_pos_given_disease, p_pos)

print(f"\nPosterior probability of disease given positive test: {posterior_prob:.4f}")

"""### Part 3: Simulate Decision-Making Under Uncertainty

---

1. Task: Write a Python function to simulate a decision-making process where
outcomes are uncertain (e.g., investment decisions). Use a probability distribution to
model the decisionâ€™s potential outcomes.
"""

import numpy as np

def simulate_decision(prob_success, reward, penalty, trials):
    results = []
    for _ in range(trials):
        if np.random.rand() < prob_success:
            results.append(reward)
        else:
            results.append(penalty)
    return np.mean(results)

"""2. Interactive Component:

"""

def simulate_decision(prob_success, reward, penalty, trials):
    return (prob_success * reward - (1 - prob_success) * penalty) * trials

prob_success = float(input("Enter the probability of success: "))
reward = float(input("Enter the reward for success: "))
penalty = float(input("Enter the penalty for failure: "))
trials = int(input("Enter the number of trials: "))

average_return = simulate_decision(prob_success, reward, penalty, trials)
print(f"\nAverage return after {trials} trials: {average_return}")

"""### Part 4: Visualize Probability Distributions

---

1. Task: Use Python to generate and visualize binomial and normal probability
distributions. The visualizations should represent real-world scenarios like coin
flips or dice rolls.
"""

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import binom, norm

def visualize_binomial(n, p):
    x = np.arange(0, n+1)
    binom_dist = binom.pmf(x, n, p)
    plt.bar(x, binom_dist)
    plt.title("Binomial Distribution (Coin Flips)")
    plt.xlabel("Number of Heads (Successes)")
    plt.ylabel("Probability")
    plt.show()

def visualize_normal(mean, std):
    x = np.linspace(mean - 4*std, mean + 4*std, 1000)
    normal_dist = norm.pdf(x, mean, std)
    plt.plot(x, normal_dist)
    plt.title("Normal Distribution (Exam Scores)")
    plt.xlabel("Score")
    plt.ylabel("Probability Density")
    plt.show()

"""2. Interactive Component:

"""

print("Choose a distribution to simulate:\n1. Binomial (Coin flips)\n2. Normal (Exam scores)\n")

dist_choice = input("Enter 1 for Binomial or 2 for Normal: ")

if dist_choice == "1":
    print("\nYou selected: Binomial (Coin flips)\n")
    n = int(input("Enter the number of trials: "))
    p = float(input("Enter the probability of heads (success): "))
    print()
    visualize_binomial(n, p)

elif dist_choice == "2":
    print("\nYou selected: Normal (Exam scores)\n")
    mean = float(input("Enter the mean score: "))
    std = float(input("Enter the standard deviation of the scores: "))
    print()
    visualize_normal(mean, std)

else:
    print("\nInvalid choice! Please enter 1 for Binomial or 2 for Normal.")

"""### Part 5: Real-World Scenario Prediction

---

1. Task: Write a Python script that uses conditional probability to predict a realworld event. The scenario should involve predicting the probability of rain based on
inputs like humidity and cloud cover.
"""

def rain_prediction(humidity_level, cloud_cover_level):
    p_humidity = humidity_level
    p_cloud = cloud_cover_level

    p_rain = 0.3
    p_humidity_given_rain = 0.8
    p_cloud_given_rain = 0.7

    return (p_humidity_given_rain * p_cloud_given_rain * p_rain) / (p_humidity * p_cloud)

"""2. Interactive Component:"""

humidity_level = float(input("Enter the humidity level (0 to 1): "))
cloud_cover_level = float(input("Enter the cloud cover level (0 to 1): "))

rain_prob = rain_prediction(humidity_level, cloud_cover_level)
print(f"\nProbability of rain: {rain_prob:.2f}")